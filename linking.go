// Code generated by GoGM v1.0.1. DO NOT EDIT
package main

import (
	"errors"
)

//LinkToSubjectOnFieldSubject links Course to Subject on the fields Course.Subject and Subject.Courses
func (l *Course) LinkToSubjectOnFieldSubject(target *Subject) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Subject = target

	if target.Courses == nil {
		target.Courses = make([]*Course, 1, 1)
		target.Courses[0] = l
	} else {
		target.Courses = append(target.Courses, l)
	}

	return nil
}

//UnlinkFromSubjectOnFieldSubject unlinks Course from Subject on the fields Course.Subject and Subject.Courses
func (l *Course) UnlinkFromSubjectOnFieldSubject(target *Subject) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Subject = nil

	if target.Courses != nil {
		for i, unlinkTarget := range target.Courses {
			if unlinkTarget.UUID == l.UUID {
				a := &target.Courses
				(*a)[i] = (*a)[len(*a)-1]
				(*a)[len(*a)-1] = nil
				*a = (*a)[:len(*a)-1]
				break
			}
		}
	}

	return nil
}

//LinkToTeacherOnFieldTeacher links Course to Teacher on the fields Course.Teacher and Teacher.Courses
func (l *Course) LinkToTeacherOnFieldTeacher(target *Teacher) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Teacher = target

	if target.Courses == nil {
		target.Courses = make([]*Course, 1, 1)
		target.Courses[0] = l
	} else {
		target.Courses = append(target.Courses, l)
	}

	return nil
}

//UnlinkFromTeacherOnFieldTeacher unlinks Course from Teacher on the fields Course.Teacher and Teacher.Courses
func (l *Course) UnlinkFromTeacherOnFieldTeacher(target *Teacher) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Teacher = nil

	if target.Courses != nil {
		for i, unlinkTarget := range target.Courses {
			if unlinkTarget.UUID == l.UUID {
				a := &target.Courses
				(*a)[i] = (*a)[len(*a)-1]
				(*a)[len(*a)-1] = nil
				*a = (*a)[:len(*a)-1]
				break
			}
		}
	}

	return nil
}

// LinkToStudentOnFieldEnrollments links Course to Student on the fields Course.Enrollments and Student.Enrollments.
// note this uses the special edge Enrollment
func (l *Course) LinkToStudentOnFieldEnrollments(target *Student, edge *Enrollment) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	if edge == nil {
		return errors.New("edge can not be nil")
	}

	err := edge.SetStartNode(target)
	if err != nil {
		return err
	}

	err = edge.SetEndNode(l)
	if err != nil {
		return err
	}

	if l.Enrollments == nil {
		l.Enrollments = make([]*Enrollment, 1, 1)
		l.Enrollments[0] = edge
	} else {
		l.Enrollments = append(l.Enrollments, edge)
	}

	if target.Enrollments == nil {
		target.Enrollments = make([]*Enrollment, 1, 1)
		target.Enrollments[0] = edge
	} else {
		target.Enrollments = append(target.Enrollments, edge)
	}

	return nil
}

// UnlinkFromStudentOnFieldEnrollments unlinks Course from Student on the fields Course.Enrollments and Student.Enrollments.
// also note this uses the special edge Enrollment
func (l *Course) UnlinkFromStudentOnFieldEnrollments(target *Student) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	if l.Enrollments != nil {
		for i, unlinkTarget := range l.Enrollments {

			obj := unlinkTarget.GetStartNode()

			checkObj, ok := obj.(*Student)
			if !ok {
				return errors.New("unable to cast unlinkTarget to [*Student]")
			}
			if checkObj.UUID == target.UUID {
				a := &l.Enrollments
				(*a)[i] = (*a)[len(*a)-1]
				(*a)[len(*a)-1] = nil
				*a = (*a)[:len(*a)-1]
				break
			}
		}
	}

	if target.Enrollments != nil {
		for i, unlinkTarget := range target.Enrollments {

			obj := unlinkTarget.GetEndNode()

			checkObj, ok := obj.(*Course)
			if !ok {
				return errors.New("unable to cast unlinkTarget to [*Course]")
			}
			if checkObj.UUID == l.UUID {
				a := &target.Enrollments
				(*a)[i] = (*a)[len(*a)-1]
				(*a)[len(*a)-1] = nil
				*a = (*a)[:len(*a)-1]
				break
			}
		}
	}

	return nil
}

// LinkToSubjectOnFieldSubjects links Department to Subject on the fields Department.Subjects and Subject.Department
func (l *Department) LinkToSubjectOnFieldSubjects(targets ...*Subject) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Subjects == nil {
			l.Subjects = make([]*Subject, 1, 1)
			l.Subjects[0] = target
		} else {
			l.Subjects = append(l.Subjects, target)
		}

		target.Department = l
	}

	return nil
}

//UnlinkFromSubjectOnFieldSubjects unlinks Department from Subject on the fields Department.Subjects and Subject.Department
func (l *Department) UnlinkFromSubjectOnFieldSubjects(targets ...*Subject) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Subjects != nil {
			for i, unlinkTarget := range l.Subjects {
				if unlinkTarget.UUID == target.UUID {
					a := &l.Subjects
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}

		target.Department = nil
	}

	return nil
}

// LinkToTeacherOnFieldTeachers links Department to Teacher on the fields Department.Teachers and Teacher.Department
func (l *Department) LinkToTeacherOnFieldTeachers(targets ...*Teacher) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Teachers == nil {
			l.Teachers = make([]*Teacher, 1, 1)
			l.Teachers[0] = target
		} else {
			l.Teachers = append(l.Teachers, target)
		}

		target.Department = l
	}

	return nil
}

//UnlinkFromTeacherOnFieldTeachers unlinks Department from Teacher on the fields Department.Teachers and Teacher.Department
func (l *Department) UnlinkFromTeacherOnFieldTeachers(targets ...*Teacher) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Teachers != nil {
			for i, unlinkTarget := range l.Teachers {
				if unlinkTarget.UUID == target.UUID {
					a := &l.Teachers
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}

		target.Department = nil
	}

	return nil
}

// LinkToCourseOnFieldEnrollments links Student to Course on the fields Student.Enrollments and Course.Enrollments.
// note this uses the special edge Enrollment
func (l *Student) LinkToCourseOnFieldEnrollments(target *Course, edge *Enrollment) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	if edge == nil {
		return errors.New("edge can not be nil")
	}

	err := edge.SetStartNode(l)
	if err != nil {
		return err
	}

	err = edge.SetEndNode(target)
	if err != nil {
		return err
	}

	if l.Enrollments == nil {
		l.Enrollments = make([]*Enrollment, 1, 1)
		l.Enrollments[0] = edge
	} else {
		l.Enrollments = append(l.Enrollments, edge)
	}

	if target.Enrollments == nil {
		target.Enrollments = make([]*Enrollment, 1, 1)
		target.Enrollments[0] = edge
	} else {
		target.Enrollments = append(target.Enrollments, edge)
	}

	return nil
}

// UnlinkFromCourseOnFieldEnrollments unlinks Student from Course on the fields Student.Enrollments and Course.Enrollments.
// also note this uses the special edge Enrollment
func (l *Student) UnlinkFromCourseOnFieldEnrollments(target *Course) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	if l.Enrollments != nil {
		for i, unlinkTarget := range l.Enrollments {

			obj := unlinkTarget.GetEndNode()

			checkObj, ok := obj.(*Course)
			if !ok {
				return errors.New("unable to cast unlinkTarget to [*Course]")
			}
			if checkObj.UUID == target.UUID {
				a := &l.Enrollments
				(*a)[i] = (*a)[len(*a)-1]
				(*a)[len(*a)-1] = nil
				*a = (*a)[:len(*a)-1]
				break
			}
		}
	}

	if target.Enrollments != nil {
		for i, unlinkTarget := range target.Enrollments {

			obj := unlinkTarget.GetStartNode()

			checkObj, ok := obj.(*Student)
			if !ok {
				return errors.New("unable to cast unlinkTarget to [*Student]")
			}
			if checkObj.UUID == l.UUID {
				a := &target.Enrollments
				(*a)[i] = (*a)[len(*a)-1]
				(*a)[len(*a)-1] = nil
				*a = (*a)[:len(*a)-1]
				break
			}
		}
	}

	return nil
}

//LinkToDepartmentOnFieldDepartment links Subject to Department on the fields Subject.Department and Department.Subjects
func (l *Subject) LinkToDepartmentOnFieldDepartment(target *Department) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Department = target

	if target.Subjects == nil {
		target.Subjects = make([]*Subject, 1, 1)
		target.Subjects[0] = l
	} else {
		target.Subjects = append(target.Subjects, l)
	}

	return nil
}

//UnlinkFromDepartmentOnFieldDepartment unlinks Subject from Department on the fields Subject.Department and Department.Subjects
func (l *Subject) UnlinkFromDepartmentOnFieldDepartment(target *Department) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Department = nil

	if target.Subjects != nil {
		for i, unlinkTarget := range target.Subjects {
			if unlinkTarget.UUID == l.UUID {
				a := &target.Subjects
				(*a)[i] = (*a)[len(*a)-1]
				(*a)[len(*a)-1] = nil
				*a = (*a)[:len(*a)-1]
				break
			}
		}
	}

	return nil
}

// LinkToTeacherOnFieldTeachers links Subject to Teacher on the fields Subject.Teachers and Teacher.Subjects
func (l *Subject) LinkToTeacherOnFieldTeachers(targets ...*Teacher) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Teachers == nil {
			l.Teachers = make([]*Teacher, 1, 1)
			l.Teachers[0] = target
		} else {
			l.Teachers = append(l.Teachers, target)
		}

		if target.Subjects == nil {
			target.Subjects = make([]*Subject, 1, 1)
			target.Subjects[0] = l
		} else {
			target.Subjects = append(target.Subjects, l)
		}
	}

	return nil
}

//UnlinkFromTeacherOnFieldTeachers unlinks Subject from Teacher on the fields Subject.Teachers and Teacher.Subjects
func (l *Subject) UnlinkFromTeacherOnFieldTeachers(targets ...*Teacher) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Teachers != nil {
			for i, unlinkTarget := range l.Teachers {
				if unlinkTarget.UUID == target.UUID {
					a := &l.Teachers
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}

		if target.Subjects != nil {
			for i, unlinkTarget := range target.Subjects {
				if unlinkTarget.UUID == l.UUID {
					a := &target.Subjects
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}
	}

	return nil
}

// LinkToCourseOnFieldCourses links Subject to Course on the fields Subject.Courses and Course.Subject
func (l *Subject) LinkToCourseOnFieldCourses(targets ...*Course) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Courses == nil {
			l.Courses = make([]*Course, 1, 1)
			l.Courses[0] = target
		} else {
			l.Courses = append(l.Courses, target)
		}

		target.Subject = l
	}

	return nil
}

//UnlinkFromCourseOnFieldCourses unlinks Subject from Course on the fields Subject.Courses and Course.Subject
func (l *Subject) UnlinkFromCourseOnFieldCourses(targets ...*Course) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Courses != nil {
			for i, unlinkTarget := range l.Courses {
				if unlinkTarget.UUID == target.UUID {
					a := &l.Courses
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}

		target.Subject = nil
	}

	return nil
}

//LinkToDepartmentOnFieldDepartment links Teacher to Department on the fields Teacher.Department and Department.Teachers
func (l *Teacher) LinkToDepartmentOnFieldDepartment(target *Department) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Department = target

	if target.Teachers == nil {
		target.Teachers = make([]*Teacher, 1, 1)
		target.Teachers[0] = l
	} else {
		target.Teachers = append(target.Teachers, l)
	}

	return nil
}

//UnlinkFromDepartmentOnFieldDepartment unlinks Teacher from Department on the fields Teacher.Department and Department.Teachers
func (l *Teacher) UnlinkFromDepartmentOnFieldDepartment(target *Department) error {
	if target == nil {
		return errors.New("start and end can not be nil")
	}

	l.Department = nil

	if target.Teachers != nil {
		for i, unlinkTarget := range target.Teachers {
			if unlinkTarget.UUID == l.UUID {
				a := &target.Teachers
				(*a)[i] = (*a)[len(*a)-1]
				(*a)[len(*a)-1] = nil
				*a = (*a)[:len(*a)-1]
				break
			}
		}
	}

	return nil
}

// LinkToSubjectOnFieldSubjects links Teacher to Subject on the fields Teacher.Subjects and Subject.Teachers
func (l *Teacher) LinkToSubjectOnFieldSubjects(targets ...*Subject) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Subjects == nil {
			l.Subjects = make([]*Subject, 1, 1)
			l.Subjects[0] = target
		} else {
			l.Subjects = append(l.Subjects, target)
		}

		if target.Teachers == nil {
			target.Teachers = make([]*Teacher, 1, 1)
			target.Teachers[0] = l
		} else {
			target.Teachers = append(target.Teachers, l)
		}
	}

	return nil
}

//UnlinkFromSubjectOnFieldSubjects unlinks Teacher from Subject on the fields Teacher.Subjects and Subject.Teachers
func (l *Teacher) UnlinkFromSubjectOnFieldSubjects(targets ...*Subject) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Subjects != nil {
			for i, unlinkTarget := range l.Subjects {
				if unlinkTarget.UUID == target.UUID {
					a := &l.Subjects
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}

		if target.Teachers != nil {
			for i, unlinkTarget := range target.Teachers {
				if unlinkTarget.UUID == l.UUID {
					a := &target.Teachers
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}
	}

	return nil
}

// LinkToCourseOnFieldCourses links Teacher to Course on the fields Teacher.Courses and Course.Teacher
func (l *Teacher) LinkToCourseOnFieldCourses(targets ...*Course) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Courses == nil {
			l.Courses = make([]*Course, 1, 1)
			l.Courses[0] = target
		} else {
			l.Courses = append(l.Courses, target)
		}

		target.Teacher = l
	}

	return nil
}

//UnlinkFromCourseOnFieldCourses unlinks Teacher from Course on the fields Teacher.Courses and Course.Teacher
func (l *Teacher) UnlinkFromCourseOnFieldCourses(targets ...*Course) error {
	if targets == nil {
		return errors.New("start and end can not be nil")
	}

	for _, target := range targets {

		if l.Courses != nil {
			for i, unlinkTarget := range l.Courses {
				if unlinkTarget.UUID == target.UUID {
					a := &l.Courses
					(*a)[i] = (*a)[len(*a)-1]
					(*a)[len(*a)-1] = nil
					*a = (*a)[:len(*a)-1]
					break
				}
			}
		}

		target.Teacher = nil
	}

	return nil
}
